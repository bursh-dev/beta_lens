<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>BetaLens</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000; color: #ff3333; font-family: 'Courier New', monospace;
    overflow: hidden; height: 100vh; width: 100vw;
    touch-action: none; user-select: none;
  }

  /* --- Screens --- */
  .screen { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
  .screen.active { display: flex; flex-direction: column; }

  /* --- Menu --- */
  #menu { justify-content: center; align-items: center; gap: 20px; }
  #menu h1 { font-size: 28px; letter-spacing: 4px; text-transform: uppercase; }
  #menu .subtitle { font-size: 12px; color: #cc2222; margin-bottom: 20px; }
  #route-list { width: 280px; max-height: 40vh; overflow-y: auto; }
  .route-item {
    display: flex; align-items: center; gap: 8px;
    padding: 10px 12px; margin: 4px 0;
    border: 1px solid #444; background: rgba(255,255,255,0.05); cursor: pointer;
    font-family: 'Courier New', monospace; font-size: 12px; color: #ccc;
  }
  .route-item:active { background: rgba(255,255,255,0.15); }
  .route-item .ri-grade { color: #ff8844; font-weight: bold; min-width: 28px; }
  .route-item .ri-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .route-item .ri-holds { color: #888; font-size: 10px; }
  .route-item .ri-btns { display: flex; gap: 4px; }
  .route-item .ri-btn {
    background: transparent; border: 1px solid #555; color: #999;
    font-family: 'Courier New', monospace; font-size: 10px; padding: 4px 6px; cursor: pointer;
  }
  .route-item .ri-btn:active { background: #555; color: #fff; }
  .route-item .ri-btn.ri-del { color: #f66; border-color: #f66; }
  .btn {
    background: transparent; border: 1px solid #ff3333; color: #ff3333;
    font-family: 'Courier New', monospace; font-size: 16px; padding: 14px 32px;
    text-transform: uppercase; letter-spacing: 2px; cursor: pointer;
    width: 260px; text-align: center;
  }
  .btn:active { background: #ff3333; color: #000; }
  .btn:disabled { opacity: 0.3; }
  .btn.small { font-size: 12px; padding: 8px 16px; width: auto; }
  @keyframes save-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  /* Save confirmation toast */
  #save-toast {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9); border: 2px solid #ff3333;
    color: #ff3333; font-family: 'Courier New', monospace;
    padding: 24px 40px; font-size: 20px; letter-spacing: 3px;
    z-index: 100; display: none; text-align: center;
  }
  #save-toast.show {
    display: block; animation: toast-fade 1.5s ease-out forwards;
  }
  @keyframes toast-fade {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
  }

  /* --- Annotate --- */
  #annotate { position: relative; }
  #annotate-viewport {
    position: absolute; top: 0; left: 56px; right: 0; bottom: 0;
    overflow: hidden; touch-action: none;
  }
  #annotate-canvas {
    transform-origin: 0 0; position: absolute;
  }

  /* --- Left Side Panel (Metallic) --- */
  #annotate-panel {
    position: absolute; top: 0; left: 0; bottom: 0; width: 56px; z-index: 5;
    background: linear-gradient(180deg, #2a2d30 0%, #1a1c1e 50%, #222528 100%);
    border-right: 1px solid #555;
    display: flex; flex-direction: column;
    font-size: 11px;
    box-shadow: 2px 0 8px rgba(0,0,0,0.5);
  }

  /* Panel button */
  .pbtn {
    width: 100%; padding: 10px 2px; text-align: center;
    background: linear-gradient(180deg, #3a3d40 0%, #2a2d30 100%);
    border: none; border-bottom: 1px solid #111; border-top: 1px solid #444;
    color: #e0e0e0; font-family: 'Courier New', monospace;
    font-size: 8px; letter-spacing: 0.5px; text-transform: uppercase;
    cursor: pointer; position: relative;
  }
  .pbtn:active { background: linear-gradient(180deg, #555 0%, #444 100%); color: #fff; }
  .pbtn .pbtn-icon {
    font-size: 18px; display: block; line-height: 1;
    margin-bottom: 2px; color: #fff;
  }

  /* Save button */
  .pbtn-save { color: #5f5; }
  .pbtn-save .pbtn-icon { color: #5f5; }
  .pbtn-save.save-ready {
    background: linear-gradient(180deg, #2a5a2a 0%, #1a3a1a 100%);
    color: #5f5;
    animation: save-pulse 1.5s ease-in-out infinite;
  }
  .pbtn-done { color: #8cf; }
  .pbtn-done .pbtn-icon { color: #8cf; }
  .pbtn-done:active { background: #456; color: #fff; }

  /* Panel info */
  .panel-info {
    padding: 6px 2px; text-align: center; font-size: 8px;
    color: #999; letter-spacing: 0.5px;
    border-bottom: 1px solid #111; border-top: 1px solid #333;
    background: linear-gradient(180deg, #252830 0%, #1e2028 100%);
    line-height: 1.4;
  }
  .panel-info .val { color: #fff; display: block; font-size: 10px; font-weight: bold; }
  .panel-grade { cursor: pointer; }
  .panel-grade .val { color: #ff8844; }
  .panel-color { cursor: pointer; }
  #panel-color-swatch {
    display: block; width: 16px; height: 16px; margin: 0 auto 2px;
    border-radius: 50%; border: 2px solid #555;
  }

  /* Version — top right corner overlay */
  .build-ver {
    position: absolute; top: 4px; right: 4px; z-index: 50;
    color: rgba(255,255,255,0.7); font-size: 11px; font-weight: bold;
    letter-spacing: 0; pointer-events: none;
    text-shadow: 0 0 4px rgba(0,0,0,0.8);
  }

  /* Zoom indicator (top right of viewport) */
  #zoom-indicator {
    position: absolute; top: 8px; right: 8px; font-size: 12px;
    color: #ff3333; z-index: 5; background: rgba(0,0,0,0.7); padding: 3px 6px;
    border: 1px solid #440000;
  }
  /* Help hint at top of viewport */
  #annotate-status {
    position: absolute; top: 0; left: 56px; right: 0;
    background: rgba(0,0,0,0.7); padding: 5px 10px; font-size: 9px;
    border-bottom: 1px solid #444; z-index: 5;
    color: #aaa; letter-spacing: 1px; text-align: center;
  }

  /* Hold edit popup */
  #hold-popup {
    display: none; position: absolute; z-index: 20;
    background: rgba(0, 0, 0, 0.92); border: 2px solid #00ffcc;
    padding: 16px; min-width: 220px;
    font-family: 'Courier New', monospace; color: #00ffcc;
  }
  #hold-popup.show { display: block; }
  #hold-popup .popup-title {
    font-size: 14px; letter-spacing: 2px; margin-bottom: 12px;
    text-align: center; border-bottom: 1px solid #006655; padding-bottom: 8px;
  }
  #hold-popup label { font-size: 12px; display: block; margin-bottom: 4px; }
  #hold-popup input[type=range] {
    width: 100%; accent-color: #00ffcc; margin-bottom: 12px;
  }
  #hold-popup .radius-val { float: right; color: #00aa88; }
  #hold-popup .popup-btns { display: flex; gap: 8px; margin-top: 8px; }
  #hold-popup .popup-btns button {
    flex: 1; padding: 10px; font-family: 'Courier New', monospace;
    font-size: 13px; cursor: pointer; border: 1px solid; background: transparent;
    text-transform: uppercase; letter-spacing: 1px;
  }
  .popup-btn-delete { color: #ff4444; border-color: #ff4444 !important; }
  .popup-btn-delete:active { background: #ff4444 !important; color: #000 !important; }
  .popup-btn-close { color: #00ffcc; border-color: #00ffcc !important; }
  .popup-btn-close:active { background: #00ffcc !important; color: #000 !important; }
  .popup-types { display: flex; gap: 4px; margin-bottom: 10px; }
  .popup-types button {
    flex: 1; padding: 6px 2px; font-family: 'Courier New', monospace;
    font-size: 9px; cursor: pointer; border: 2px solid #333; background: transparent;
    text-transform: uppercase; letter-spacing: 0.5px; color: #999;
  }
  .popup-types button.active { border-color: currentColor; font-weight: bold; }

  /* --- Live --- */
  #live { position: relative; overflow: hidden; }
  #live-viewport { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform-origin: 0 0; }
  #live-video { width: 100%; height: 100%; object-fit: cover; }
  #live-canvas {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
  }
  #live-zoom-indicator {
    position: absolute; bottom: 12px; right: 12px; z-index: 15;
    color: #ff3333; font-size: 14px; letter-spacing: 2px;
    background: rgba(0,0,0,0.7); padding: 4px 8px; border: 1px solid #440000;
    display: none;
  }
  #live-hud {
    position: absolute; top: 0; left: 0; right: 0;
    background: rgba(0,0,0,0.8); padding: 10px 10px 10px 90px;
    font-size: 12px; border-bottom: 2px solid #660000; z-index: 5;
  }
  #live-hud .status { font-size: 16px; font-weight: bold; letter-spacing: 2px; }
  #live-hud .status.locked { color: #ff3333; }
  #live-hud .status.lost { color: #ff3333; opacity: 0.5; }
  #live-hud .telemetry { color: #aa2222; margin-top: 2px; font-size: 10px; }
  #live-back {
    position: absolute; top: 0; left: 0; z-index: 10;
    padding: 10px 14px; border-right: 1px solid #440000;
    border-bottom: 2px solid #660000;
  }
  #live-error {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9); border: 2px solid #ff3333;
    color: #ff3333; padding: 24px; max-width: 90%; text-align: center;
    font-size: 14px; letter-spacing: 1px; line-height: 1.6; z-index: 20;
    display: none;
  }
  #live-error.show { display: block; }
  .scanline {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px
    );
    pointer-events: none;
  }

  /* Loading overlay */
  #loading {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: #000; display: flex; flex-direction: column;
    justify-content: center; align-items: center; z-index: 999;
    font-size: 14px; gap: 10px;
  }
  #loading.hidden { display: none; }
  #load-progress { color: #aa2222; }
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading">
  <div>// INITIALIZING OPENCV</div>
  <div id="load-progress">loading...</div>
</div>

<!-- Menu Screen -->
<div id="menu" class="screen">
  <h1>BetaLens</h1>
  <div class="subtitle">// BOULDERING ROUTE AR SYSTEM</div>
  <div id="menu-ver" style="font-size:14px; font-weight:bold; color:#00e5ff; margin-top:4px; text-align:center;"></div>
  <button class="btn" onclick="startAnnotate(null)">+ New Route</button>
  <div id="route-list"></div>
  <div id="menu-info" style="font-size:11px; color:#666; margin-top:10px; text-align:center;"></div>
  <div style="display:flex; gap:8px; margin-top:10px;">
    <button class="btn small" onclick="exportRoutes()">Export</button>
    <button class="btn small" onclick="document.getElementById('import-input').click()">Import</button>
  </div>
  <input type="file" id="import-input" accept=".json" style="display:none" onchange="importRoutes(this)">
</div>

<!-- Annotate Screen -->
<div id="annotate" class="screen">
  <div id="annotate-status">// TAP TO PLACE HOLDS</div>
  <div id="annotate-viewport">
    <canvas id="annotate-canvas"></canvas>
  </div>
  <div id="zoom-indicator">1.0x</div>
  <div class="build-ver" id="anno-ver"></div>
  <div id="hold-popup">
    <div class="popup-title">// EDIT <span id="popup-hold-id">H1</span></div>
    <label>TYPE</label>
    <div class="popup-types" id="popup-types"></div>
    <label>SIZE <span class="radius-val" id="popup-radius-val">40</span></label>
    <input type="range" id="popup-radius" min="10" max="250" value="40"
           oninput="onPopupResize(this.value)">
    <div class="popup-btns">
      <button class="popup-btn-delete" onclick="popupDelete()">Delete</button>
      <button class="popup-btn-close" onclick="popupClose()">OK</button>
    </div>
  </div>
  <div id="annotate-panel">
    <button class="pbtn pbtn-done" onclick="annotateBack()"><span class="pbtn-icon">&lt;</span>DONE</button>
    <button class="pbtn pbtn-save" id="btn-save" onclick="annotateSave()"><span class="pbtn-icon">&#9654;</span>SAVE</button>
    <div class="panel-info">
      <span class="val" id="panel-holds">0</span>HOLDS
    </div>
    <div class="panel-info">
      <span class="val" id="panel-zoom">1.0x</span>ZOOM
    </div>
    <div class="panel-info panel-grade" onclick="cycleGrade()">
      <span class="val" id="panel-grade">?</span>GRADE
    </div>
    <div class="panel-info panel-color" onclick="cycleRouteColor()">
      <span class="val" id="panel-color-swatch"></span>COLOR
    </div>
    <button class="pbtn" onclick="annotateLoadImage()"><span class="pbtn-icon">+</span>LOAD</button>
    <button class="pbtn" onclick="annotateCapturePhoto()"><span class="pbtn-icon">O</span>CAM</button>
    <button class="pbtn" onclick="annotateUndo()"><span class="pbtn-icon">&larr;</span>UNDO</button>
    <button class="pbtn" onclick="annotateClear()"><span class="pbtn-icon">X</span>CLR</button>
    <button class="pbtn" onclick="annotateResetZoom()"><span class="pbtn-icon">[ ]</span>1:1</button>
  </div>
  <input type="file" id="file-input" accept="image/*" style="display:none">
  <input type="file" id="capture-input" accept="image/*" capture="environment" style="display:none">
</div>

<!-- Save Toast -->
<div id="save-toast">ROUTE SAVED</div>

<!-- Live Tracking Screen -->
<div id="live" class="screen">
  <div id="live-viewport">
    <video id="live-video" autoplay playsinline muted></video>
    <canvas id="live-canvas"></canvas>
  </div>
  <div class="scanline"></div>
  <div id="live-zoom-indicator"></div>
  <div id="live-hud">
    <button class="btn small" id="live-back" onclick="stopLive()">Back</button>
    <div class="status" id="hud-status">INITIALIZING...</div>
    <div class="telemetry" id="hud-telemetry"></div>
    <div class="telemetry" id="hud-ver"></div>
  </div>
  <div id="live-error"></div>
</div>

<script>
const BUILD_VER = '260301.9';

// Hold type color presets (for labels only now)
const HOLD_COLORS = {
  start:  { color: '#44ff44' },
  hand:   { color: '#44aaff' },
  foot:   { color: '#ffcc44' },
  finish: { color: '#ff4466' },
};

// Route color presets — the paint color for all holds in a route
const ROUTE_COLORS = [
  { name: 'CYAN',    hex: '#00e5ff', rgb: [0, 229, 255] },
  { name: 'MAGENTA', hex: '#ff44cc', rgb: [255, 68, 204] },
  { name: 'LIME',    hex: '#76ff03', rgb: [118, 255, 3] },
  { name: 'ORANGE',  hex: '#ff9100', rgb: [255, 145, 0] },
  { name: 'PURPLE',  hex: '#b388ff', rgb: [179, 136, 255] },
  { name: 'YELLOW',  hex: '#ffea00', rgb: [255, 234, 0] },
  { name: 'RED',     hex: '#ff1744', rgb: [255, 23, 68] },
  { name: 'WHITE',   hex: '#ffffff', rgb: [255, 255, 255] },
];
const HOLD_TYPES = ['start', 'hand', 'foot', 'finish'];
const GRADE_OPTIONS = ['?','V0','V1','V2','V3','V4','V5','V6','V7','V8','V9','V10','V11','V12','V13','V14','V15','V16'];

// ===== GLOBALS =====
let cvReady = false;
let routeData = null;       // { anchor: { dataUrl, width, height }, holds: [...] }
let currentRouteIdx = -1;   // index in saved routes array, -1 = new route
let anchorMat = null;
let anchorKp = null;
let anchorDesc = null;
let detector = null;
let bfMatcher = null;

// Annotate state
let annoImg = null;         // HTMLImageElement
let annoHolds = [];
let annoHistory = [];
let annoCanvas, annoCtx;
let defaultRadius = 30;

// Zoom/pan state
let viewZoom = 1;
let viewPanX = 0;
let viewPanY = 0;
let baseScale = 1;         // fit-to-screen scale
let pinchStartDist = 0;
let pinchStartZoom = 1;
let pinchStartPanX = 0, pinchStartPanY = 0;
let panStartX = 0, panStartY = 0;
let panViewStartX = 0, panViewStartY = 0;
let isTwoFinger = false;
let totalTouchMovement = 0;
const TAP_THRESHOLD = 12;   // px of movement allowed for a tap

// Hold interaction state
let editingHoldIdx = -1;    // index of hold being edited in popup
let draggingHoldIdx = -1;   // index of hold being dragged
let dragStartImgX = 0, dragStartImgY = 0;  // hold position at drag start

// Live state
let liveStream = null;
let liveRunning = false;
let liveVideo, liveCanvas, liveCtx;

// Live zoom/pan state
let liveZoom = 1;
let livePanX = 0, livePanY = 0;
let livePinchStartDist = 0, livePinchStartZoom = 1;
let livePinchStartPanX = 0, livePinchStartPanY = 0;
let livePanStartX = 0, livePanStartY = 0;
let livePanViewStartX = 0, livePanViewStartY = 0;
let liveIsTwoFinger = false;
let liveZoomIndicatorTimer = null;
let frameCount = 0;
let trackedCount = 0;
let lastFps = 0;
let fpsFrames = 0;
let fpsTime = 0;
// Hold last position on brief tracking loss
let smoothedHolds = null;
let trackLostFrames = 0;
const MAX_LOST_FRAMES = 5;

// ===== OPENCV LOADING =====
function onOpenCvReady() {
  cvReady = true;
  document.getElementById('loading').classList.add('hidden');
  // Set build version in both screens
  const av = document.getElementById('anno-ver');
  const hv = document.getElementById('hud-ver');
  if (av) av.textContent = 'v' + BUILD_VER;
  if (hv) hv.textContent = 'v' + BUILD_VER;
  const mv = document.getElementById('menu-ver');
  if (mv) mv.textContent = 'v' + BUILD_VER;
  showMenu();
}

// Load OpenCV.js
(function loadOpenCV() {
  const script = document.createElement('script');
  script.src = 'https://docs.opencv.org/4.9.0/opencv.js';
  script.async = true;
  script.onload = () => {
    if (typeof cv !== 'undefined') {
      if (cv.getBuildInformation) {
        onOpenCvReady();
      } else {
        cv['onRuntimeInitialized'] = onOpenCvReady;
      }
    }
  };
  script.onerror = () => {
    document.getElementById('load-progress').textContent = 'FAILED — check network';
  };
  document.head.appendChild(script);
  // Progress dots
  let dots = 0;
  const iv = setInterval(() => {
    if (cvReady) { clearInterval(iv); return; }
    dots = (dots + 1) % 4;
    document.getElementById('load-progress').textContent = 'loading' + '.'.repeat(dots);
  }, 500);
})();

// ===== NAVIGATION =====
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function getRoutes() {
  try { return JSON.parse(localStorage.getItem('betalens_routes') || '[]'); }
  catch { return []; }
}
function saveRoutes(routes) {
  localStorage.setItem('betalens_routes', JSON.stringify(routes));
}
// Migrate old single-route format
function migrateOldRoute() {
  const old = localStorage.getItem('betalens_route');
  if (old) {
    const routes = getRoutes();
    const r = JSON.parse(old);
    r.name = 'Route 1';
    routes.push(r);
    saveRoutes(routes);
    localStorage.removeItem('betalens_route');
  }
}

function showMenu() {
  showScreen('menu');
  migrateOldRoute();
  const routes = getRoutes();
  const list = document.getElementById('route-list');
  list.innerHTML = '';
  if (routes.length === 0) {
    document.getElementById('menu-info').textContent = 'No routes — create one';
  } else {
    document.getElementById('menu-info').textContent = routes.length + ' route(s) saved';
    routes.forEach((r, i) => {
      const div = document.createElement('div');
      div.className = 'route-item';
      div.innerHTML =
        `<span class="ri-grade">${r.grade || '?'}</span>` +
        `<span class="ri-name">${r.name || 'Route ' + (i+1)}</span>` +
        `<span class="ri-holds">${r.holds.length}h</span>` +
        `<span class="ri-btns">` +
          `<button class="ri-btn" onclick="event.stopPropagation();startAnnotate(${i})">Edit</button>` +
          `<button class="ri-btn" onclick="event.stopPropagation();selectRoute(${i})">Track</button>` +
          `<button class="ri-btn ri-del" onclick="event.stopPropagation();deleteRoute(${i})">X</button>` +
        `</span>`;
      list.appendChild(div);
    });
  }
}

function selectRoute(idx) {
  const routes = getRoutes();
  routeData = routes[idx];
  currentRouteIdx = idx;
  startLive();
}

function deleteRoute(idx) {
  if (!confirm('Delete this route?')) return;
  const routes = getRoutes();
  routes.splice(idx, 1);
  saveRoutes(routes);
  showMenu();
}

function exportRoutes() {
  const routes = getRoutes();
  if (routes.length === 0) { alert('No routes to export'); return; }
  const blob = new Blob([JSON.stringify(routes)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'betalens-routes.json';
  a.click();
  URL.revokeObjectURL(url);
}

function importRoutes(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);
      if (!Array.isArray(imported)) throw new Error('Not an array');
      const routes = getRoutes();
      let count = 0;
      for (const r of imported) {
        if (r.holds && r.anchor) { routes.push(r); count++; }
      }
      saveRoutes(routes);
      alert(count + ' route(s) imported');
      showMenu();
    } catch (err) {
      alert('Invalid file: ' + err.message);
    }
  };
  reader.readAsText(file);
  input.value = '';
}

// ===== ANNOTATE =====
function startAnnotate(routeIdx) {
  showScreen('annotate');
  annoCanvas = document.getElementById('annotate-canvas');
  annoCtx = annoCanvas.getContext('2d');
  annoHolds = [];
  annoHistory = [];
  annoImg = null;
  annoSavedSnapshot = '';
  viewZoom = 1; viewPanX = 0; viewPanY = 0;

  // Load existing route if editing
  if (routeIdx !== null && routeIdx !== undefined) {
    currentRouteIdx = routeIdx;
    const routes = getRoutes();
    routeData = routes[routeIdx];
  } else {
    currentRouteIdx = -1;
    routeData = null;
  }

  currentGrade = (routeData && routeData.grade) ? routeData.grade : '?';
  document.getElementById('panel-grade').textContent = currentGrade;

  currentColorIdx = (routeData && routeData.colorIdx !== undefined) ? routeData.colorIdx : 0;
  updateColorSwatch();

  // If we have a saved route, reload it
  if (routeData && routeData.anchor && routeData.anchor.dataUrl) {
    const img = new Image();
    img.onload = () => {
      annoImg = img;
      annoHolds = routeData.holds.map(h => ({...h}));
      annoSavedSnapshot = JSON.stringify(annoHolds);
      fitCanvas();
      drawAnnotation();
    };
    img.src = routeData.anchor.dataUrl;
  }

  // Touch handlers on viewport
  const vp = document.getElementById('annotate-viewport');
  vp.addEventListener('touchstart', onAnnoTouchStart, { passive: false });
  vp.addEventListener('touchmove', onAnnoTouchMove, { passive: false });
  vp.addEventListener('touchend', onAnnoTouchEnd, { passive: false });
  vp.addEventListener('click', onAnnotateClick);
  // Mouse wheel zoom for desktop testing
  vp.addEventListener('wheel', onAnnoWheel, { passive: false });
  updateAnnotateStatus();
}

function fitCanvas() {
  if (!annoImg) return;
  const vp = document.getElementById('annotate-viewport');
  const availW = vp.offsetWidth;
  const availH = vp.offsetHeight;

  // Canvas at full image resolution
  annoCanvas.width = annoImg.width;
  annoCanvas.height = annoImg.height;

  // Compute base scale to fit image in viewport
  baseScale = Math.min(availW / annoImg.width, availH / annoImg.height);

  // Reset zoom/pan
  viewZoom = 1;
  viewPanX = (availW - annoImg.width * baseScale) / 2;
  viewPanY = (availH - annoImg.height * baseScale) / 2;
  applyTransform();
}

function clampPan() {
  if (!annoImg) return;
  const vp = document.getElementById('annotate-viewport');
  const vpW = vp.offsetWidth, vpH = vp.offsetHeight;
  const s = baseScale * viewZoom;
  const imgW = annoImg.width * s, imgH = annoImg.height * s;
  // Keep at least 20% of image visible on each side
  const margin = 0.2;
  viewPanX = Math.max(-imgW * (1 - margin), Math.min(vpW * (1 - margin), viewPanX));
  viewPanY = Math.max(-imgH * (1 - margin), Math.min(vpH * (1 - margin), viewPanY));
}

function applyTransform() {
  clampPan();
  const s = baseScale * viewZoom;
  annoCanvas.style.transform = `translate(${viewPanX}px, ${viewPanY}px) scale(${s})`;
  document.getElementById('zoom-indicator').textContent = `${viewZoom.toFixed(1)}x`;
  const pz = document.getElementById('panel-zoom');
  if (pz) pz.textContent = `${viewZoom.toFixed(1)}x`;
}

function screenToImageCoords(clientX, clientY) {
  const vp = document.getElementById('annotate-viewport');
  const rect = vp.getBoundingClientRect();
  const sx = clientX - rect.left;
  const sy = clientY - rect.top;
  const s = baseScale * viewZoom;
  return {
    x: Math.round((sx - viewPanX) / s),
    y: Math.round((sy - viewPanY) / s)
  };
}

function getTouchDist(t1, t2) {
  return Math.sqrt((t1.clientX - t2.clientX) ** 2 + (t1.clientY - t2.clientY) ** 2);
}

function getTouchCenter(t1, t2) {
  return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
}

function onAnnoTouchStart(e) {
  e.preventDefault();
  if (editingHoldIdx >= 0) return; // popup open, ignore canvas touches
  totalTouchMovement = 0;
  draggingHoldIdx = -1;

  if (e.touches.length === 2) {
    isTwoFinger = true;
    pinchStartDist = getTouchDist(e.touches[0], e.touches[1]);
    pinchStartZoom = viewZoom;
    pinchStartPanX = viewPanX;
    pinchStartPanY = viewPanY;
    const center = getTouchCenter(e.touches[0], e.touches[1]);
    panStartX = center.x;
    panStartY = center.y;
  } else if (e.touches.length === 1) {
    isTwoFinger = false;
    panStartX = e.touches[0].clientX;
    panStartY = e.touches[0].clientY;
    panViewStartX = viewPanX;
    panViewStartY = viewPanY;

    // Check if touching a hold (for drag)
    if (annoImg) {
      const { x, y } = screenToImageCoords(panStartX, panStartY);
      const idx = findNearestHold(x, y);
      if (idx >= 0) {
        draggingHoldIdx = idx;
        dragStartImgX = annoHolds[idx].x;
        dragStartImgY = annoHolds[idx].y;
      }
    }
  }
}

function onAnnoTouchMove(e) {
  e.preventDefault();
  if (editingHoldIdx >= 0) return;
  if (e.touches.length === 2) {
    isTwoFinger = true;
    totalTouchMovement = 999;
    draggingHoldIdx = -1;

    const dist = getTouchDist(e.touches[0], e.touches[1]);
    const newZoom = Math.max(1, Math.min(10, pinchStartZoom * (dist / pinchStartDist)));

    const center = getTouchCenter(e.touches[0], e.touches[1]);
    const vp = document.getElementById('annotate-viewport');
    const rect = vp.getBoundingClientRect();
    // Zoom toward finger center
    const cx = center.x - rect.left;
    const cy = center.y - rect.top;
    const ratio = newZoom / pinchStartZoom;
    viewPanX = cx - (cx - pinchStartPanX) * ratio + (center.x - panStartX);
    viewPanY = cy - (cy - pinchStartPanY) * ratio + (center.y - panStartY);

    viewZoom = newZoom;
    applyTransform();
  } else if (e.touches.length === 1) {
    const dx = e.touches[0].clientX - panStartX;
    const dy = e.touches[0].clientY - panStartY;
    totalTouchMovement += Math.abs(dx) + Math.abs(dy);

    if (draggingHoldIdx >= 0 && totalTouchMovement > TAP_THRESHOLD) {
      // Drag hold to new position
      const s = baseScale * viewZoom;
      annoHolds[draggingHoldIdx].x = Math.round(dragStartImgX + dx / s);
      annoHolds[draggingHoldIdx].y = Math.round(dragStartImgY + dy / s);
      drawAnnotation();
    } else if (draggingHoldIdx < 0 && viewZoom > 1.05 && totalTouchMovement > TAP_THRESHOLD) {
      // Pan viewport
      viewPanX = panViewStartX + dx;
      viewPanY = panViewStartY + dy;
      applyTransform();
    }
  }
}

function onAnnoTouchEnd(e) {
  e.preventDefault();
  if (editingHoldIdx >= 0) return;

  if (!isTwoFinger && totalTouchMovement < TAP_THRESHOLD
      && e.changedTouches.length === 1 && annoImg) {
    const t = e.changedTouches[0];
    const { x, y } = screenToImageCoords(t.clientX, t.clientY);

    // Check mini edit button first
    const btnIdx = hitEditButton(x, y);
    if (btnIdx >= 0) {
      showHoldPopup(btnIdx, t.clientX, t.clientY);
    } else if (x >= 0 && x < annoImg.width && y >= 0 && y < annoImg.height) {
      // Tap on empty space — place new hold
      if (findNearestHold(x, y) < 0) {
        addHold(x, y);
      }
    }
  }

  // Save undo state if a hold was dragged
  if (draggingHoldIdx >= 0 && totalTouchMovement >= TAP_THRESHOLD) {
    annoHistory.push(annoHolds.map(h => ({...h})));
  }
  draggingHoldIdx = -1;

  if (e.touches.length === 0) {
    isTwoFinger = false;
    if (viewZoom < 1.05 && annoImg) {
      viewZoom = 1;
      const vp = document.getElementById('annotate-viewport');
      viewPanX = (vp.offsetWidth - annoImg.width * baseScale) / 2;
      viewPanY = (vp.offsetHeight - annoImg.height * baseScale) / 2;
      applyTransform();
    }
  }
}

function onAnnotateClick(e) {
  // Desktop mouse click
  if (!annoImg || ('ontouchstart' in window)) return;
  const { x, y } = screenToImageCoords(e.clientX, e.clientY);
  if (x >= 0 && x < annoImg.width && y >= 0 && y < annoImg.height) {
    addHold(x, y);
  }
}

function onAnnoWheel(e) {
  e.preventDefault();
  if (!annoImg) return;
  const vp = document.getElementById('annotate-viewport');
  const rect = vp.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;

  const oldZoom = viewZoom;
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  viewZoom = Math.max(1, Math.min(10, viewZoom * delta));

  // Zoom toward cursor
  const ratio = (baseScale * viewZoom) / (baseScale * oldZoom);
  viewPanX = cx - (cx - viewPanX) * ratio;
  viewPanY = cy - (cy - viewPanY) * ratio;
  applyTransform();
}

function drawAnnotation() {
  if (!annoImg) return;
  annoCtx.clearRect(0, 0, annoCanvas.width, annoCanvas.height);
  annoCtx.drawImage(annoImg, 0, 0);

  const rc = ROUTE_COLORS[currentColorIdx];
  for (let i = 0; i < annoHolds.length; i++) {
    const h = annoHolds[i];
    const isEditing = (i === editingHoldIdx);
    const [r, g, b] = isEditing ? [255, 255, 0] : rc.rgb;

    // Soft outer glow
    const grad = annoCtx.createRadialGradient(h.x, h.y, h.r * 0.3, h.x, h.y, h.r * 1.2);
    grad.addColorStop(0, `rgba(${r},${g},${b},0.55)`);
    grad.addColorStop(0.7, `rgba(${r},${g},${b},0.35)`);
    grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
    annoCtx.beginPath();
    annoCtx.arc(h.x, h.y, h.r * 1.2, 0, Math.PI * 2);
    annoCtx.fillStyle = grad;
    annoCtx.fill();

    // Solid paint fill
    annoCtx.beginPath();
    annoCtx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
    annoCtx.fillStyle = `rgba(${r},${g},${b},0.45)`;
    annoCtx.fill();

    // Thin border
    annoCtx.beginPath();
    annoCtx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
    annoCtx.strokeStyle = `rgba(${r},${g},${b},0.8)`;
    annoCtx.lineWidth = 2;
    annoCtx.stroke();

    // Type label
    const fontSize = Math.max(22, h.r * 0.5);
    annoCtx.font = `bold ${fontSize}px Courier New`;
    const label = h.kind.toUpperCase();
    const lw = annoCtx.measureText(label).width;
    annoCtx.fillStyle = `rgba(0,0,0,0.6)`;
    annoCtx.fillRect(h.x - lw / 2 - 4, h.y + h.r + 4, lw + 8, fontSize + 4);
    annoCtx.fillStyle = `rgb(${r},${g},${b})`;
    annoCtx.fillText(label, h.x - lw / 2, h.y + h.r + fontSize + 2);

    // Mini edit button (top-right of hold)
    const btnR = Math.max(16, h.r * 0.35);
    const btnX = h.x + h.r * 0.7;
    const btnY = h.y - h.r * 0.7;
    annoCtx.beginPath();
    annoCtx.arc(btnX, btnY, btnR, 0, Math.PI * 2);
    annoCtx.fillStyle = 'rgba(0,0,0,0.7)';
    annoCtx.fill();
    annoCtx.strokeStyle = `rgba(${r},${g},${b},0.9)`;
    annoCtx.lineWidth = 2;
    annoCtx.stroke();
    // Gear icon (⚙)
    const gearSize = Math.max(14, btnR * 1.1);
    annoCtx.font = `${gearSize}px sans-serif`;
    annoCtx.fillStyle = `rgb(${r},${g},${b})`;
    annoCtx.textAlign = 'center';
    annoCtx.textBaseline = 'middle';
    annoCtx.fillText('\u2699', btnX, btnY + 1);
    annoCtx.textAlign = 'start';
    annoCtx.textBaseline = 'alphabetic';
  }
  updateAnnotateStatus();
  updateSaveButton();
}

function findNearestHold(x, y) {
  let bestIdx = -1, bestDist = Infinity;
  for (let i = 0; i < annoHolds.length; i++) {
    const h = annoHolds[i];
    const dist = Math.sqrt((h.x - x) ** 2 + (h.y - y) ** 2);
    if (dist < h.r * 1.5 && dist < bestDist) {
      bestDist = dist;
      bestIdx = i;
    }
  }
  return bestIdx;
}

function hitEditButton(imgX, imgY) {
  for (let i = 0; i < annoHolds.length; i++) {
    const h = annoHolds[i];
    const btnR = Math.max(16, h.r * 0.35);
    const btnX = h.x + h.r * 0.7;
    const btnY = h.y - h.r * 0.7;
    const dist = Math.sqrt((imgX - btnX) ** 2 + (imgY - btnY) ** 2);
    if (dist < btnR * 1.5) return i;
  }
  return -1;
}

function addHold(x, y) {
  annoHistory.push(annoHolds.map(h => ({...h})));
  const id = 'H' + (annoHolds.length + 1);
  const r = Math.round(Math.min(annoImg.width, annoImg.height) * 0.03);
  annoHolds.push({ id, x, y, r, kind: 'hand' });
  drawAnnotation();
}

function showHoldPopup(idx, screenX, screenY) {
  editingHoldIdx = idx;
  const h = annoHolds[idx];
  const popup = document.getElementById('hold-popup');
  document.getElementById('popup-hold-id').textContent = h.id;
  const slider = document.getElementById('popup-radius');
  slider.value = h.r;
  document.getElementById('popup-radius-val').textContent = h.r;

  // Populate type buttons
  const typesDiv = document.getElementById('popup-types');
  typesDiv.innerHTML = '';
  HOLD_TYPES.forEach(t => {
    const btn = document.createElement('button');
    btn.textContent = t;
    btn.style.color = HOLD_COLORS[t].color;
    if (h.kind === t) btn.classList.add('active');
    btn.onclick = () => {
      annoHolds[editingHoldIdx].kind = t;
      typesDiv.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      drawAnnotation();
    };
    typesDiv.appendChild(btn);
  });

  // Position popup near tap but keep in viewport
  const vp = document.getElementById('annotate-viewport');
  const rect = vp.getBoundingClientRect();
  let px = screenX - rect.left - 110;
  let py = screenY - rect.top - 160;
  px = Math.max(4, Math.min(rect.width - 228, px));
  py = Math.max(4, Math.min(rect.height - 180, py));
  popup.style.left = px + 'px';
  popup.style.top = py + 'px';
  popup.classList.add('show');

  // Snapshot for undo
  annoHistory.push(annoHolds.map(h => ({...h})));

  // Highlight the selected hold
  drawAnnotation();
}

function onPopupResize(val) {
  if (editingHoldIdx < 0) return;
  val = parseInt(val);
  annoHolds[editingHoldIdx].r = val;
  document.getElementById('popup-radius-val').textContent = val;
  drawAnnotation();
}

function popupDelete() {
  if (editingHoldIdx < 0) return;
  annoHolds.splice(editingHoldIdx, 1);
  renumberHolds();
  editingHoldIdx = -1;
  document.getElementById('hold-popup').classList.remove('show');
  drawAnnotation();
}

function popupClose() {
  editingHoldIdx = -1;
  document.getElementById('hold-popup').classList.remove('show');
  drawAnnotation();
}

function renumberHolds() {
  annoHolds.forEach((h, i) => h.id = 'H' + (i + 1));
}

function annotateUndo() {
  if (annoHistory.length > 0) {
    annoHolds = annoHistory.pop();
    drawAnnotation();
  }
}

function annotateClear() {
  if (annoHolds.length > 0) {
    annoHistory.push(annoHolds.map(h => ({...h})));
    annoHolds = [];
    drawAnnotation();
  }
}

function cycleGrade() {
  const idx = GRADE_OPTIONS.indexOf(currentGrade);
  currentGrade = GRADE_OPTIONS[(idx + 1) % GRADE_OPTIONS.length];
  document.getElementById('panel-grade').textContent = currentGrade;
}

function cycleRouteColor() {
  currentColorIdx = (currentColorIdx + 1) % ROUTE_COLORS.length;
  updateColorSwatch();
  if (annoImg) drawAnnotation();
}

function updateColorSwatch() {
  const swatch = document.getElementById('panel-color-swatch');
  swatch.style.background = ROUTE_COLORS[currentColorIdx].hex;
}

function annotateResetZoom() {
  if (!annoImg) return;
  const vp = document.getElementById('annotate-viewport');
  viewZoom = 1;
  viewPanX = (vp.offsetWidth - annoImg.width * baseScale) / 2;
  viewPanY = (vp.offsetHeight - annoImg.height * baseScale) / 2;
  applyTransform();
}

function updateAnnotateStatus() {
  const el = document.getElementById('annotate-status');
  const ph = document.getElementById('panel-holds');
  if (!annoImg) {
    el.textContent = '// LOAD OR TAKE A PHOTO';
  } else {
    el.textContent = '// TAP=ADD  LONG-PRESS=EDIT  PINCH=ZOOM';
  }
  if (ph) ph.textContent = annoHolds.length;
}

function annotateLoadImage() {
  const input = document.getElementById('file-input');
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadImageFile(file);
  };
  input.click();
}

function annotateCapturePhoto() {
  const input = document.getElementById('capture-input');
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadImageFile(file);
  };
  input.click();
}

function loadImageFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const img = new Image();
    img.onload = () => {
      annoImg = img;
      annoHolds = [];
      annoHistory = [];
      fitCanvas();
      drawAnnotation();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

let annoSavedSnapshot = '';  // track if holds changed since last save
let currentGrade = '?';      // route grade (V0-V16)
let currentColorIdx = 0;     // index into ROUTE_COLORS

function annotateSave() {
  if (!annoImg || annoHolds.length === 0) {
    alert('Add at least one hold first');
    return;
  }
  // Downscale anchor image for storage (max 1024px)
  const maxDim = 1024;
  let sw = annoImg.width, sh = annoImg.height;
  const scale = Math.min(maxDim / sw, maxDim / sh, 1);
  sw = Math.round(sw * scale);
  sh = Math.round(sh * scale);

  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = sw;
  tmpCanvas.height = sh;
  const tmpCtx = tmpCanvas.getContext('2d');
  tmpCtx.drawImage(annoImg, 0, 0, sw, sh);
  const dataUrl = tmpCanvas.toDataURL('image/jpeg', 0.8);

  // Scale hold coordinates
  const scaledHolds = annoHolds.map(h => ({
    ...h,
    x: Math.round(h.x * scale),
    y: Math.round(h.y * scale),
    r: Math.round(h.r * scale)
  }));

  routeData = {
    anchor: { dataUrl, width: sw, height: sh },
    holds: scaledHolds,
    grade: currentGrade,
    colorIdx: currentColorIdx,
    name: routeData && routeData.name ? routeData.name : 'Route ' + (getRoutes().length + 1),
    savedAt: new Date().toISOString()
  };

  // Save to routes array
  const routes = getRoutes();
  if (currentRouteIdx >= 0 && currentRouteIdx < routes.length) {
    routeData.name = routes[currentRouteIdx].name || routeData.name;
    routes[currentRouteIdx] = routeData;
  } else {
    routes.push(routeData);
    currentRouteIdx = routes.length - 1;
  }
  saveRoutes(routes);
  annoSavedSnapshot = JSON.stringify(annoHolds);
  updateSaveButton();

  // Show save toast
  const toast = document.getElementById('save-toast');
  toast.textContent = `ROUTE SAVED — ${scaledHolds.length} HOLDS`;
  toast.classList.remove('show');
  void toast.offsetWidth;  // force reflow for re-trigger
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 1500);

  document.getElementById('annotate-status').textContent =
    `// SAVED: ${scaledHolds.length} holds (${sw}x${sh})`;
}

function hasUnsavedChanges() {
  return annoHolds.length > 0 && JSON.stringify(annoHolds) !== annoSavedSnapshot;
}

function updateSaveButton() {
  const btn = document.getElementById('btn-save');
  if (hasUnsavedChanges()) {
    btn.classList.add('save-ready');
    btn.innerHTML = '<span class="pbtn-icon">&#9654;</span>SAVE!';
  } else {
    btn.classList.remove('save-ready');
    btn.innerHTML = '<span class="pbtn-icon">&#9654;</span>SAVE';
  }
}

function annotateBack() {
  if (hasUnsavedChanges()) {
    if (confirm('You have unsaved holds. Save before leaving?')) {
      annotateSave();
    }
  }
  showMenu();
}

// ===== LIVE TRACKING =====
async function startLive() {
  if (!routeData) { alert('Annotate a route first'); return; }
  if (!cvReady) { alert('OpenCV not ready'); return; }

  showScreen('live');
  initLiveZoom();

  // Check camera API availability
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    const dbg = 'Protocol: ' + location.protocol + '\nHost: ' + location.host +
      '\nSecure: ' + window.isSecureContext + '\nUA: ' + navigator.userAgent.slice(0,80);
    setTimeout(() => showLiveError('CAMERA NOT AVAILABLE',
      'Camera API not found.\n\n' + dbg + '\n\n' +
      'If you see "Not secure" in the address bar,\ntap the lock icon > Site settings > allow Camera.'), 100);
    return;
  }
  liveVideo = document.getElementById('live-video');
  liveCanvas = document.getElementById('live-canvas');
  liveCtx = liveCanvas.getContext('2d');
  frameCount = 0;
  trackedCount = 0;
  fpsFrames = 0;
  fpsTime = performance.now();
  smoothedHolds = null;
  trackLostFrames = 0;

  // Initialize OpenCV objects
  initTracker();

  // Start camera
  try {
    liveStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    liveVideo.srcObject = liveStream;
    await liveVideo.play();

    // Wait for video dimensions
    await new Promise(resolve => {
      const check = () => {
        if (liveVideo.videoWidth > 0) resolve();
        else requestAnimationFrame(check);
      };
      check();
    });

    liveCanvas.width = liveVideo.videoWidth;
    liveCanvas.height = liveVideo.videoHeight;

    liveRunning = true;
    trackingLoop();
  } catch (err) {
    showLiveError('CAMERA ERROR', err.message +
      '\n\nMake sure you open this page in Chrome (not Telegram or other in-app browsers).' +
      '\n\nURL must be https:// or localhost.');
  }
}

function showLiveError(title, msg) {
  document.getElementById('hud-status').textContent = title;
  const el = document.getElementById('live-error');
  el.innerHTML = `<div style="font-size:18px;margin-bottom:12px;letter-spacing:3px">${title}</div>` +
    `<div style="font-size:12px;color:#aa3333;white-space:pre-line">${msg}</div>`;
  el.classList.add('show');
}

function initTracker() {
  // Clean up previous
  if (anchorMat) { anchorMat.delete(); anchorMat = null; }
  if (anchorKp) { anchorKp.delete(); anchorKp = null; }
  if (anchorDesc) { anchorDesc.delete(); anchorDesc = null; }
  if (orb) { orb.delete(); orb = null; }
  if (bfMatcher) { bfMatcher.delete(); bfMatcher = null; }

  // Load anchor image into OpenCV Mat
  const img = new Image();
  img.onload = () => {
    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = img.width;
    tmpCanvas.height = img.height;
    const tmpCtx = tmpCanvas.getContext('2d');
    tmpCtx.drawImage(img, 0, 0);
    const imgData = tmpCtx.getImageData(0, 0, img.width, img.height);

    anchorMat = cv.matFromImageData(imgData);
    const anchorGray = new cv.Mat();
    cv.cvtColor(anchorMat, anchorGray, cv.COLOR_RGBA2GRAY);

    detector = new cv.ORB(2000, 1.2, 12);
    anchorKp = new cv.KeyPointVector();
    anchorDesc = new cv.Mat();
    detector.detectAndCompute(anchorGray, new cv.Mat(), anchorKp, anchorDesc);

    bfMatcher = new cv.BFMatcher(cv.NORM_HAMMING, false);

    anchorGray.delete();
    console.log(`Anchor: ${anchorKp.size()} features`);
  };
  img.src = routeData.anchor.dataUrl;
}

function trackingLoop() {
  if (!liveRunning) return;

  const t0 = performance.now();
  frameCount++;

  // Capture frame
  liveCtx.drawImage(liveVideo, 0, 0);

  let tracking = false;
  let matchCount = 0;
  let transformedHolds = [];

  if (anchorDesc && anchorDesc.rows > 0) {
    try {
      // Get current frame
      const imgData = liveCtx.getImageData(0, 0, liveCanvas.width, liveCanvas.height);
      const frameMat = cv.matFromImageData(imgData);
      const frameGray = new cv.Mat();
      cv.cvtColor(frameMat, frameGray, cv.COLOR_RGBA2GRAY);

      // Detect features
      const frameKp = new cv.KeyPointVector();
      const frameDesc = new cv.Mat();
      detector.detectAndCompute(frameGray, new cv.Mat(), frameKp, frameDesc);

      if (frameDesc.rows >= 10) {
        // Match
        const matches = new cv.DMatchVectorVector();
        bfMatcher.knnMatch(anchorDesc, frameDesc, matches, 2);

        // Ratio test
        const good = [];
        for (let i = 0; i < matches.size(); i++) {
          const match = matches.get(i);
          if (match.size() >= 2) {
            const m = match.get(0);
            const n = match.get(1);
            if (m.distance < 0.80 * n.distance) {
              good.push(m);
            }
          }
        }
        matchCount = good.length;

        if (good.length >= 10) {
          // Build point arrays
          const srcPts = cv.matFromArray(good.length, 1, cv.CV_32FC2,
            good.flatMap(m => {
              const kp = anchorKp.get(m.queryIdx);
              return [kp.pt.x, kp.pt.y];
            }));
          const dstPts = cv.matFromArray(good.length, 1, cv.CV_32FC2,
            good.flatMap(m => {
              const kp = frameKp.get(m.trainIdx);
              return [kp.pt.x, kp.pt.y];
            }));

          const mask = new cv.Mat();
          const H = cv.findHomography(srcPts, dstPts, cv.RANSAC, 5.0, mask);

          if (H && H.rows === 3) {
            // Transform holds
            const holds = routeData.holds;
            for (const hold of holds) {
              const pts = cv.matFromArray(1, 1, cv.CV_32FC2, [hold.x, hold.y]);
              const dst = new cv.Mat();
              cv.perspectiveTransform(pts, dst, H);
              const cx = dst.data32F[0];
              const cy = dst.data32F[1];

              // Transform radius
              const ptsR = cv.matFromArray(1, 1, cv.CV_32FC2, [hold.x + hold.r, hold.y]);
              const dstR = new cv.Mat();
              cv.perspectiveTransform(ptsR, dstR, H);
              const rx = dstR.data32F[0];
              const ry = dstR.data32F[1];
              const r = Math.sqrt((rx - cx) ** 2 + (ry - cy) ** 2);

              transformedHolds.push({ id: hold.id, x: cx, y: cy, r, kind: hold.kind });

              pts.delete(); dst.delete(); ptsR.delete(); dstR.delete();
            }
            tracking = true;
            trackedCount++;
            H.delete();
          }
          mask.delete(); srcPts.delete(); dstPts.delete();
        }
        matches.delete();
      }
      frameKp.delete(); frameDesc.delete(); frameGray.delete(); frameMat.delete();
    } catch (err) {
      console.warn('Tracking error:', err);
    }
  }

  // Hold last position on brief tracking loss (no EMA lag)
  if (tracking && transformedHolds.length > 0) {
    trackLostFrames = 0;
    smoothedHolds = transformedHolds.map(h => ({ ...h }));
  } else {
    trackLostFrames++;
    if (smoothedHolds && trackLostFrames <= MAX_LOST_FRAMES) {
      transformedHolds = smoothedHolds;
      tracking = true;
    } else {
      smoothedHolds = null;
    }
  }

  // Draw overlay
  drawLiveOverlay(tracking, transformedHolds, matchCount);

  // FPS calculation
  fpsFrames++;
  const now = performance.now();
  if (now - fpsTime >= 1000) {
    lastFps = fpsFrames / ((now - fpsTime) / 1000);
    fpsFrames = 0;
    fpsTime = now;
  }

  // Update HUD
  const statusEl = document.getElementById('hud-status');
  if (tracking) {
    statusEl.textContent = 'TARGET LOCK';
    statusEl.className = 'status locked';
  } else {
    statusEl.textContent = frameCount % 10 < 7 ? 'TARGET LOST' : '';
    statusEl.className = 'status lost';
  }

  const trkPct = frameCount > 0 ? (trackedCount / frameCount * 100).toFixed(0) : 0;
  document.getElementById('hud-telemetry').textContent =
    `FEAT MATCH: ${String(matchCount).padStart(3, '0')}  |  ` +
    `TRK: ${trkPct}%  |  ` +
    `FPS: ${lastFps.toFixed(1)}  |  ` +
    `FRM: ${String(frameCount).padStart(5, '0')}`;

  // Schedule next frame — skip frames if processing is slow
  const elapsed = performance.now() - t0;
  if (elapsed > 100) {
    // Processing is slow, skip next frame
    setTimeout(() => requestAnimationFrame(trackingLoop), 0);
  } else {
    requestAnimationFrame(trackingLoop);
  }
}

function drawLiveOverlay(tracking, holds, matchCount) {
  // We already drew the video frame, now draw holds on top
  if (!tracking) return;

  const rcIdx = routeData && routeData.colorIdx !== undefined ? routeData.colorIdx : 0;
  const rc = ROUTE_COLORS[rcIdx] || ROUTE_COLORS[0];
  const [cr, cg, cb] = rc.rgb;

  for (const h of holds) {
    // Soft radial glow
    const grad = liveCtx.createRadialGradient(h.x, h.y, h.r * 0.3, h.x, h.y, h.r * 1.2);
    grad.addColorStop(0, `rgba(${cr},${cg},${cb},0.5)`);
    grad.addColorStop(0.7, `rgba(${cr},${cg},${cb},0.3)`);
    grad.addColorStop(1, `rgba(${cr},${cg},${cb},0)`);
    liveCtx.beginPath();
    liveCtx.arc(h.x, h.y, h.r * 1.2, 0, Math.PI * 2);
    liveCtx.fillStyle = grad;
    liveCtx.fill();

    // Solid paint
    liveCtx.beginPath();
    liveCtx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
    liveCtx.fillStyle = `rgba(${cr},${cg},${cb},0.4)`;
    liveCtx.fill();

    // Thin border
    liveCtx.beginPath();
    liveCtx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
    liveCtx.strokeStyle = `rgba(${cr},${cg},${cb},0.7)`;
    liveCtx.lineWidth = 2;
    liveCtx.stroke();

    // Type label below
    const fs = Math.max(14, h.r * 0.4);
    liveCtx.font = `bold ${fs}px Courier New`;
    const lbl = h.kind.toUpperCase();
    const lw = liveCtx.measureText(lbl).width;
    liveCtx.fillStyle = `rgba(0,0,0,0.6)`;
    liveCtx.fillRect(h.x - lw / 2 - 3, h.y + h.r + 2, lw + 6, fs + 3);
    liveCtx.fillStyle = `rgb(${cr},${cg},${cb})`;
    liveCtx.fillText(lbl, h.x - lw / 2, h.y + h.r + fs);
  }
}

// --- Live zoom/pan ---
function applyLiveTransform() {
  const vp = document.getElementById('live-viewport');
  vp.style.transform = `translate(${livePanX}px, ${livePanY}px) scale(${liveZoom})`;
  const ind = document.getElementById('live-zoom-indicator');
  if (liveZoom > 1.05) {
    ind.textContent = `${liveZoom.toFixed(1)}x`;
    ind.style.display = 'block';
    clearTimeout(liveZoomIndicatorTimer);
    liveZoomIndicatorTimer = setTimeout(() => { ind.style.display = 'none'; }, 2000);
  } else {
    ind.style.display = 'none';
  }
}

function onLiveTouchStart(e) {
  // Don't intercept taps on HUD buttons
  if (e.target.closest('#live-hud')) return;
  if (e.touches.length === 2) {
    e.preventDefault();
    liveIsTwoFinger = true;
    livePinchStartDist = getTouchDist(e.touches[0], e.touches[1]);
    livePinchStartZoom = liveZoom;
    livePinchStartPanX = livePanX;
    livePinchStartPanY = livePanY;
    const c = getTouchCenter(e.touches[0], e.touches[1]);
    livePanStartX = c.x;
    livePanStartY = c.y;
  } else if (e.touches.length === 1 && liveZoom > 1.05) {
    e.preventDefault();
    liveIsTwoFinger = false;
    livePanStartX = e.touches[0].clientX;
    livePanStartY = e.touches[0].clientY;
    livePanViewStartX = livePanX;
    livePanViewStartY = livePanY;
  }
}

function onLiveTouchMove(e) {
  if (e.touches.length === 2) {
    e.preventDefault();
    liveIsTwoFinger = true;
    const dist = getTouchDist(e.touches[0], e.touches[1]);
    liveZoom = Math.max(1, Math.min(5, livePinchStartZoom * (dist / livePinchStartDist)));
    const c = getTouchCenter(e.touches[0], e.touches[1]);
    livePanX = livePinchStartPanX + (c.x - livePanStartX);
    livePanY = livePinchStartPanY + (c.y - livePanStartY);
    applyLiveTransform();
  } else if (e.touches.length === 1 && liveZoom > 1.05 && !liveIsTwoFinger) {
    e.preventDefault();
    livePanX = livePanViewStartX + (e.touches[0].clientX - livePanStartX);
    livePanY = livePanViewStartY + (e.touches[0].clientY - livePanStartY);
    applyLiveTransform();
  }
}

function onLiveTouchEnd(e) {
  if (e.touches.length === 0) {
    liveIsTwoFinger = false;
    // Snap back to 1x if barely zoomed
    if (liveZoom < 1.05) {
      liveZoom = 1; livePanX = 0; livePanY = 0;
      applyLiveTransform();
    }
  }
}

function initLiveZoom() {
  liveZoom = 1; livePanX = 0; livePanY = 0;
  const el = document.getElementById('live');
  el.addEventListener('touchstart', onLiveTouchStart, { passive: false });
  el.addEventListener('touchmove', onLiveTouchMove, { passive: false });
  el.addEventListener('touchend', onLiveTouchEnd, { passive: false });
}

function stopLive() {
  liveRunning = false;
  if (liveStream) {
    liveStream.getTracks().forEach(t => t.stop());
    liveStream = null;
  }
  liveZoom = 1; livePanX = 0; livePanY = 0;
  const vp = document.getElementById('live-viewport');
  if (vp) vp.style.transform = '';
  showMenu();
}

// Handle resize
window.addEventListener('resize', () => {
  if (annoImg) { fitCanvas(); drawAnnotation(); }
});
</script>
</body>
</html>
